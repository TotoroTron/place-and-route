\documentclass{article}
\usepackage{hyperref}
\usepackage{enumitem}
\usepackage{graphicx}

\begin{document}
\title{Technical Paper Proposal: \\ Placement Algorithms for Heterogenous FPGAs}
\author{Brian B Cheng \\ Department of Electrical and Computer Engineering}


\date{}
\maketitle

\section{Proposal}

In modern software development, the process of compiling high-level languages like C++ or Java into executable machine code is highly efficient and streamlined. 
The software toolchains only consist of compilers and scripts and are mostly open source and easy to learn. 
The compilation is where most of the magic happens.
Through multiple stages of lexing, parsing, and optimizations, the compiler takes the developer's program and produces working machine code.
The developer can influence a few optimization flags if needed, but for the most part, the developer simply runs the default compiler command and is presented with the final product.
All of this happens within milliseconds to seconds, even for large projects. 

In the same way that a compiler takes a high-level C++ file and assembles machine code ready to be executed on a CPU, an Electronic Design Automation (EDA) tool takes a high-level Verilog file and produces a hardware configuration in the form of a bitstream, ready to be deployed onto an FPGA or ASIC. In a superficial way, they perform the same task but for different industries. 
One for software, the other for hardware.

Dramatic transition.

In the FPGA world, the design entry to product pipeline is despairingly complex by comparison. 
First, the design entry. The engineer describes a digital system using a high-level HDL like Verilog or VHDL. 
Then the engineer submits the design entry to an EDA like Vivado or Quartus to perform three stages of automated design. 
These are: synthesis, placement, and routing. 
All three are NP-hard problems.
For even modest designs like binary counters or 8-bit CPUs that utilize a small percentage of the available resources on the FPGA, the EDA will spend a minimum of a couple minutes building the design.
The EDA build time increases exponentially with the scale of the project. 
Projects that utilize 80\% or more of the FPGA's resources may build for hours, and for the high-end devices like Xilinx's Kintex which boast millions of logical elements, can take days.
Sometimes the EDA cannot fit the design onto the device.

\section{Abbreviations}
\begin{itemize}[label={--}, left=0.25cm]
    \item \textbf{FPGA}: Field Programmable Gate Array
    \item \textbf{VLSI}: Very Large Scale Integration
    \item \textbf{EDA}: Electronic Design Automation
    \item \textbf{VHSIC}: Very High Speed Integrated Circuits
    \item \textbf{HDL}: Hardware Description Language
    \item \textbf{VHDL}: VHSIC HDL
    \item \textbf{HLS}: High Level Synthesis: Generating synthesizable HDL from high-level software languages. A company might want to have a software engineer write C or C++ code and have a program translate it into synthesizable Verilog. This can can boost productivity and save the company the need to hire a hardware engineer.
    \item \textbf{IP}: Intellectual Property: In FPGA context, this means pre-built modules or subsystems like a hardened microprocessor or Ethernet controller. These are usually proprietary.
    \item \textbf{SoC}: System on Chip: An FPGA device (chip) that features hardened IP in addition to the programmable logic fabric.
    \item \textbf{PL-PS}: Programmable Logic - Processing System: A design that utilizes the on-chip hard microprocessor in conjunction with the programmable logic fabric.
    \item \textbf{EDIF}: Electronic Design Interchange Format
    \item \textbf{HPWL}: Half Perimeter Wire Length
\end{itemize}

\section{Keywords}
\begin{itemize}
    \item FPGA, EDA, Synthesis, Placement, Routing, Parallel, Optimization
\end{itemize}

\section{Ideas}
\begin{itemize}[label={\textbullet}, left=0.25cm]
    \item \textbf{FPGA}: Field Programmable Gate Array
    \begin{itemize}[label={--}, left=0.25cm]
        \item FPGA Vendors:
        \begin{itemize}[label={$\cdot$}, left=0.25cm]
            \item AMD-Xilinx ($\sim$50\% FPGA vendor market share)
            \item Intel-Altera ($\sim$35\% share)
            \item Lattice
            \item Microsemi
        \end{itemize}
    \end{itemize}

    \item \textbf{EDA}: Electronic Design Automation
    \begin{itemize}[label={--}, left=0.25cm]
        \item Proprietary software for FPGA and VLSI development:
        \begin{itemize}[label={$\cdot$}, left=0.25cm]
            \item Xilinx - Vivado (Design + Simulation) + Vitis (HLS + PL-PS codesign)
            \item Altera - Quartus (Design) + ModelSim (Simulation)
            \item Synopsis (VLSI)
            \item Cadence (VLSI)
        \end{itemize}
        \item Open source software for FPGA development:
        \begin{itemize}[label={$\cdot$}, left=0.25cm]
            \item \textbf{VTR}: Simulated Annealing placer for FPGAs. Popular among researchers who study placement techniques. 
                Commonly referred to as an "academic placer".
            \item \textbf{OSS-CAD}: a full-flow software suite that includes ABC synthesis, Yosys synthesis, Yosys nextpnr.
            \item \textbf{AMF-Placer}: Analytical Placer for FPGAs
            \item \textbf{RapidWright}: Semi-open source API that provides backend access to Xilinx Vivado EDA using design checkpoints.
            \item \textbf{RapidLayout}: Hard Block Placer for Systolic Arrays. Built with RapidWright.
            \item \textbf{RapidStream}: HLS Placer. Built with RapidWright.
            \item \textbf{DREAMPlace}: GPU-powered deep learning placement for VLSI.
            \item \textbf{DREAMPlaceFPGA}: DREAMPlace, adapted to FPGAs via the RapidWright API.
        \end{itemize}
    \end{itemize}
    
    \item \textbf{Synthesis}
    \begin{itemize}[label={--}, left=0.25cm]
        \item Takes a design written in a high-level HDL like VHDL or Verilog and "synthesizes" a \textbf{logical netlist} out of it. 
        \item The logical netlist is usually generated as an EDIF, JSON, or a low-level Verilog file. 
        \item The netlist describes the necessary basic elements of logic (BELs) and the wired connections between them that are necessary to implement the design.
    \end{itemize}

    \item \textbf{Placement}
    \begin{itemize}[label={--}, left=0.25cm]
        \item Takes the \textbf{logical netlist} and produces a \textbf{physical netlist}.
        \item For each BEL in the netlist, assign the BEL to a Cell, Site, and Tile on the physical FPGA device.
    \end{itemize}

    \item \textbf{Routing}
    \begin{itemize}[label={--}, left=0.25cm]
        \item Takes the \textbf{physical netlist} and maps the connections between BELs onto wires, interconnects, and switchboxes on the FPGA.
    \end{itemize}

\end{itemize}

\newpage
\begin{figure}
    \begin{center}
        \includegraphics[width=0.75\textwidth]{figures/kraftwerk2.png}
    \end{center}
    \caption{Landscape of VLSI placement techniques (Spindler) \cite{kraftwerk2} }
    \label{fig:kraftwerk2}
\end{figure}
\begin{figure}
    \begin{center}
        \includegraphics[width=0.95\textwidth]{figures/ProCha.png}
    \end{center}
    \caption{Historical timeline of VLSI placement techniques (Markov) \cite{ProCha} }
    \label{fig:ProCha}
\end{figure}

This is a citation for AMFPlacer. \cite{AMFPlacer}

\newpage
\bibliographystyle{ieeetr}
\nocite{*}
\bibliography{
    references/surveys,
    references/rapidwright,
    references/fpga_placement,
    references/vlsi_placement,
}
\end{document}


