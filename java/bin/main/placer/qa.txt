Relationship between Site and SiteInst? How BlockPlacer relocates SiteInsts during iterative placement?

Hello, I am currently trying my hand at building a (very crude) general BEL packer and placer as part of my MS technical paper and am using RapidWright to achieve that goal.
Over the past few months I have learned how to do the following with RapidWright:
    1) Design entry via Verilog.

    2) synth_design and export dcp via Vivado.

    3) Open the synthesized dcp via RapidWright.

    4) Read the EDIFNetlist, find the set of all unique cellTypes, group EDIFHierCellInsts by their type:
        Map<String, List<EDIFHierCellInst>> EDIFCellGroups ... ;
        where the key strings are:
            DSP48E1, RAMB18E1, CARRY4, FDRE, FDSE, LUT2-6 (all in one group), etc.

    5) Find basic cell patters such as:
        Carry chains 
            traverse carry chains by accessing CO[3] and CIN ports, checking if CO[3] is null, if their nets are GND or connected to another CARRY4
        DSP cascades
            iterative cell traversal:
            for each DSP48E1, for each getPort("CO"), getHierNet, getSinks, if any != null and sink belongs to another DSP, currCell = sink
        LUT-FF pairs
            grouped by set of unique SR-CE net pairs (FFs can only be placed in the same site if share the same SR-CE net)

    6) Create SiteInsts, si.createCell() using cell patterns found
        This is where the EDIFHierCellInsts are actually packed into SiteInsts.
        For simplicity of intrasite routing, each CLB site can have maximum 4 LUTs and 4 FFs.

    7) Randomly place the SiteInsts onto the device like so:

        protected Site selectCLBSite(List<Site> occupiedCLBSites) {
            Random rand = new Random();
            List<SiteTypeEnum> compatibleSiteTypes = new ArrayList<SiteTypeEnum>();
            compatibleSiteTypes.add(SiteTypeEnum.SLICEL);
            compatibleSiteTypes.add(SiteTypeEnum.SLICEM);
            int randIndex = rand.nextInt(compatibleSiteTypes.size());
            SiteTypeEnum selectedSiteType = compatibleSiteTypes.get(randIndex);

            List<Site> availableSites = new ArrayList<Site>(
                    Arrays.asList(device.getAllCompatibleSites(selectedSiteType)));
            availableSites.removeAll(occupiedCLBSites);

            // Random selection.
            Site selectedSite = availableSites.get(rand.nextInt(availableSites.size()));
            // Select first available.
            // Site selectedSite = availableSites.get(0);

            occupiedCLBSites.add(selectedSite);

            return selectedSite;
        }

        DSP and RAM site selection are also chosen similarly.

    8) IntraSite routing via si.routeSite(). 
        Manual intervention if the default PIP settings are incorrect via:
        si.unrouteIntraSiteNet() and si.addSitePIP()


Now I am not sure I'm not sure how to proceed.
My goal is to create a basic simulated annealing placer and potentially an analytical placer if time permits.
This means placing SiteInsts, evaluating a cost function (HPWL), unplacing, moving, and replacing SiteInsts, reevaluating cost function, etc.
I had hoped to use Site/SiteInst as the atomic unit for placement/movement, however I'm no longer sure that's the best way to proceed or if I'm using SiteInst in a way it's not really meant to be used.

There are four constructors for SiteInst as specified in the documentation:
    SiteInst()
    SiteInst(String name, Design design, SiteTypeEnum type, Site site)
    SiteInst(String name, Module module, SiteTypeEnum type, Site site)
    SiteInst(String name, SiteTypeEnum type)

From my understanding, in order to create a new SiteInst() and instill it with Cell-BEL mapping information, a physical device Site must first be specified.
If I were to unplace() that SiteInst, it would lose its Cell-BEL mapping information.

I was hoping that by using the 4th constructor, SiteInst(String name, SiteTypeEnum type), i could treat them as "floating" SiteInsts where they retain their Cell-BEL mapping information and even intraSite routing information regardless of their placement status.



I looked elsewhere in the RW repository and found this code snippet in RelocationTools.java that seems to confirm this:

    boolean revertPlacement = false;
    for (Map.Entry<SiteInst, Site> e : oldSite.entrySet()) {
        Site srcSite = e.getValue();
        Tile srcTile = srcSite.getTile();
        Tile destTile = srcTile.getTileXYNeighbor(tileColOffset, tileRowOffset);
        Site destSite = srcSite.getCorrespondingSite(srcSite.getSiteTypeEnum(), destTile);
        SiteInst srcSiteInst = e.getKey();
        assert(destSite != srcSite);
        if (destTile == null || destSite == null) {
            String destTileName = srcTile.getRootName() + "_X" + (srcTile.getTileXCoordinate() + tileColOffset)
                    + "Y" + (srcTile.getTileYCoordinate() + tileRowOffset);
            System.out.println("ERROR: Failed to move SiteInst '" + srcSiteInst.getName() + "' from Tile '" + srcTile.getName()
                    + "' to Tile '" + destTileName + "'");
            revertPlacement = true;
            continue;
        }
        SiteInst destSiteInst = design.getSiteInstFromSite(destSite);
        if (destSiteInst != null) {
            if (destSiteInst.getName().startsWith("STATIC_SOURCE")) {
                destSiteInst.unPlace();
            } else {
                System.out.println("ERROR: Failed to move SiteInst '" + srcSiteInst.getName() + "' from Tile '" + srcTile.getName()
                        + "' to Tile '" + destTile.getName() + "' as it is already occupied");
                revertPlacement = true;
                continue;
            }
        }

        srcSiteInst.place(destSite);
    }


